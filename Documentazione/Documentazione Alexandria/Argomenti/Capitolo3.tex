\chapter{Design del Sistema}
\raggedright{\section{Analisi dell'architettura e motivazioni}}
L'architettura del software precedente era strutturata in maniera tale che fosse monolitica: era composta da tre strati gerarchici, dove il più basso, la View, era il \gls{layer} deputato al \gls{front end}, il layer centrale, i Model, era deputato alla gestione dei modelli richiesti dal sistema e infine il layer Database, che gestiva la manipolazione dei dati ed eventuale loro creazione, rimozione o modifica. \\
In Alexandria, nella fase di progettazione dell'architettura del sistema, il compito più arduo è stato quello di mantenere il Database e riutilizzare il codice sorgente ma ristrutturare l'architettura per renderla più flessibile e non monolitica, in particolare di adottare l'architettura \gls{REST}. Il sistema infatti prevede più sottoinsiemi di layer che collettivamente compongono l'applicativo: il front end è composto da tre layer, uno per la comunicazione \gls{HTTP} con il server, uno per l'interfaccia grafica e un'altra per la modellazione delle classi richieste. Il layer per la comunicazione a sua volta è composto da un layer aggiuntivo per la corretta gestione dei dati, utilizzato solamente dal front end nella trasmissione dei dati o per la richiesta di lettura. L'intero sottosistema del front end è inglobato nell'architettura \gls{REST} che comprende anche il lato server. Quest'ultimo infatti rispecchia la rappresentazione di una architettura REST basata su HTTP, dove lo stato dell'applicazione e le funzionalità sono divisi in risorse, ogni risorsa è unica e indirizzabile usando sintassi universale per uso nei link ipertestuali. Tutte le risorse sono condivise come interfaccia uniforme per il trasferimento di stato tra front end e risorse, questo consiste in un insieme vincolato di operazioni ben definite, un insieme vincolato di contenuti, opzionalmente supportato da codice a richiesta.
Abbiamo deciso di implementare un'architettura REST per la versatilità di richiedere e trasmettere le risorse al server, per la falicità del mapping del Database nelle entità e soprattuto perché perfetto per le nostre esigenze: il database durante la fase di progettazione già era implementato, ma non era completamente utilizzabile per via dell'architettura monolitica del precedente sistema. L'API Rest si è presentata come un'ottima scelta per poter implementare un nuovo sistema senza dover realizzare dal nulla lo stesso database.

\raggedright{\section{Descrizione e motivazioni delle scelte tecnologiche adottate}
Le tecnologie usate durante lo sviluppo del progetto sono essenzialmente tre: PostgreSQL per il Database Management System, Spring Boot per l'API Rest da implementare per la comunicazione con il DBMS e Flutter per lo sviluppo del front-end. Di seguito descrizione e motivazioni delle nostre scelte.

\raggedright{\subsection{PostgreSQL}}
PostgreSQL è un \gls{DBMS} di tipo relazionale in cui è possibile inserire dati, modificarli,  ricercarli ed eliminarli. E' inoltre fornito di funzionalità aggiuntive come la creazione di funzioni tramite PLPGSQL o SQL Dinamico. \\
In Alexandria, il back-end è gestito in parte da PostgreSQL. Il motivo principale di questa scelta è la già nota esistenza di un Database apposito e le modifche pensate durante la fase di progettazione non erano tali da dover reimplementare interamente il Database. Non avrebbe avuto senso dover reimplementare lo stesso database con le stesse funzioni per un nuovo DBMS, perdendo così tempo per la progettazione dell'applicativo, anche perché il Database risultava perfettamente funzionante durante la fase di testing del vecchio applicativo. \\
Il DBMS ci ha permesso di implementare funzioni apposite per determinate query, soprattutto per le relazioni ricorsive, tipi enumerativi e cast dedicati, funzionalità che magari non erano presenti in altri DBMS. 
\raggedright{\subsection{Spring Boot}}
\gls{Spring Boot} è un API Rest atto a implementare un applicativo capace di comunicare mediante archiettura REST. 
\raggedright{\subsection{Flutter}}

\raggedright{\section{Diagrammi delle classi di design}}

\raggedright{\section{Diagrammi di sequenza di design}}

\raggedright{\section{Codice sorgente e Dockerfile}}
